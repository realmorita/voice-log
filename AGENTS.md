# コーディングガイド

## 命名

### 1. 明確で具体的な単語を選ぶ

* **Get** のような曖昧語を避け、状況に応じてより正確な動詞を使う
  例: `Fetch`, `Download`, `Load`, `Parse`, `Deserialize`, `Acquire`, `Resolve`

### 2. 汎用的すぎる名前を避ける

* `tmp`, `retval` など「意味を運ばない名前」は原則禁止
* 例外: スコープが極小で、用途が一目で確実に分かる場合のみ許容

### 3. 意味が伝わる具体名で説明する

* 抽象的な名前で意図を隠さない
  例: `ServerCanStart()` より `CanListenOnPort()` の方が具体的

### 4. 変数名に重要情報を埋め込む

* 単位を名前に含める
  * 例: ミリ秒 → `*_ms`
* エスケープ等の前処理が必要な値は名前で区別する
  * 例: `raw_*` を付けて「未加工」を明示する

### 5. スコープに応じて名前の長さを変える

* **スコープが大きい**（数画面に及ぶ）変数には **長い説明的名前**を付ける
* **スコープが小さい**（数行）変数のみ短い名前を許す
* 「暗号的な 1〜2 文字」は長寿命変数に使わない

### 6. 記法（大文字・アンダースコア）に意味を持たせる

* 例: クラスのメンバ変数に `_` を付けてローカル変数と区別する（プロジェクト規約として統一する）

### 7. 誤解されない名前にする

* 上下限: `min_`, `max_` を使う
* 範囲表現:
  * **包含的範囲**: `first`, `last`
  * **半開区間（begin inclusive / end exclusive）**: `begin`, `end`
* ブール値:
  * `is`, `has`, `can`, `should` など肯定形を使う
  * `disable_ssl` のような **否定形**は避ける（読み間違い・二重否定を誘発）

### 8. ユーザー（読み手）の期待を裏切らない

* `get()` や `size()` は **軽量**であることが期待される
  重い処理・I/O・ロックなどを含むなら、名前で明示する（例: `LoadSizeFromDisk()`）

---

## 整形・一貫性

### 1. 同じ処理は同じシルエットにする

* 複数箇所で似たことをするなら、構造・並び・命名の型を揃える
  読み手が「同じパターン」と認識できることが重要

### 2. "列" を揃えて俯瞰しやすくする

* 代入・引数・構造体初期化など、視認性が上がる場面では整列を検討する
  （ただし整列のための差分がノイズになる場合はやりすぎない）

### 3. 意味のある順番を決めて守る

* ある場所で `A, B, C` なら、別の場所で `B, C, A` にしない
* 並び順（重要度・処理順・依存順など）を決めたらプロジェクト全体で統一する

### 4. 空行で論理段落を作る

* 大きなブロックは空行で区切り、「読みの単位」を揃える

---

## コメント

### 1. コメントすべきでないこと

* コードから自明に抽出できる事実
* ひどい命名や設計の穴埋め（コメントで補うのではなく、コードを直す）

### 2. 記録すべき "思考"

* **なぜこの設計／実装なのか**（他案ではなくこの案を選んだ理由）
  * 監督コメンタリー（設計判断の背景）
* TODO / XXX などで **既知の欠陥・未対応**を明示する
* 定数値の **背景**（根拠、由来、制約条件）

### 3. 読み手の立場で書く

* 「ここで読む人が驚くポイント」を予測して説明する
* 平均的な読み手が意外に思う挙動は文書化しておく
* ファイル／クラスには **全体像コメント**を書く
* ブロックコメントは細部ではなく **高レベルの意図**をまとめる

### 4. 代名詞を避ける

* 「これ」「それ」など、複数候補を指し得る表現を避ける
  何を指すかを名詞で明示する

### 5. 引数が分かりにくいならインラインコメント

* 例: `Function(/* arg = */ ...)` のように、読み手が迷う箇所だけ補助する

### 6. 入出力例は慎重に選ぶ

* コメントに例を書くなら、誤解を生まない最小かつ代表的な例を選ぶ

---

## 変数・スコープ設計

* 不要な変数（邪魔な変数）を削除する
* 変数のスコープは可能な限り小さくする
* **一度だけ書き込む変数**を優先する（再代入を減らし追跡可能性を上げる）

---

## テスト

### 1. トップレベルを簡潔にする

* 入出力のテストは可能なら 1 行で表現できる形に寄せる

### 2. 失敗時に直しやすいメッセージ

* 失敗したときに「どこが」「何が」「期待と実際がどう違うか」が分かるエラーメッセージを出す

### 3. 最も単純で有効な入力を使う

* まず最小ケースで意図を固定し、必要に応じて境界値・異常系を追加する

### 4. テスト名は説明的にする

* `TEST_1()` のような番号は避ける
* 例: `TEST_<対象>_<条件>()` のように「何をどんな状況で」テストするかを名前に含める

---

## テスト駆動開発(TDD)

本プロジェクトでは、テスト駆動開発を採用する。

### TDDの実践手順

機能追加や変更を行う際は、以下の5ステップを繰り返す:

#### ステップ1: テストリストを作成する

**やること:**
- 実装する機能の振る舞いをリストアップする
- コメントやメモとして書き出す（例: `// TODO: 正常系、タイムアウト時、空データ時...`）

**重要な原則:**
- **振る舞いの分析**に集中し、実装の詳細は考えない
- 「どう呼び出されるべきか」だけを考え、「どう実装するか」は後回し

**コーディングツールとしての実装:**
```
# 実装開始時にテストリストをコメントで提示する
# TODO: テストリスト
# - [ ] 正常系: 有効な入力で期待値を返す
# - [ ] 境界値: 空文字列/null/最大値を処理する
# - [ ] 異常系: 不正な入力でエラーを返す
```

#### ステップ2: ひとつだけテストを書く

**やること:**
- リストから**1項目だけ**選び、具体的なテストコードに翻訳する
- 準備(Arrange)・実行(Act)・検証(Assert)を含む完全なテストを書く
- テストを実行し、失敗することを確認する（Red）

**重要な原則:**
- 一度に複数のテストを書かない
- アサーションから逆向きに書くと設計しやすい場合がある
- この段階で**インターフェイスの設計**を行う（メソッド名、引数、戻り値）

**よくある誤り:**
- テストリストの全項目をいきなりテストコードにしてしまう
- アサーションのないテストを書く

**コーディングツールとしての実装:**
```python
# ステップ1のリストから1つ選ぶ
# - [x] 正常系: 有効な入力で期待値を返す ← これを実装中
# - [ ] 境界値: ...
# - [ ] 異常系: ...

def test_calculates_sum_for_valid_input():
    # Arrange
    calculator = Calculator()

    # Act
    result = calculator.add(2, 3)

    # Assert
    assert result == 5  # まだ実装がないのでこのテストは失敗する(Red)
```

#### ステップ3: テストを成功させる

**やること:**
- 最小限のプロダクトコードを書いて、テストを成功させる（Green）
- 既存の全テストも引き続き成功することを確認する
- 新たな気づきがあればテストリストに追加する

**重要な原則:**
- **まず動かし、それから正しくする**（リファクタリングは次のステップ）
- テスト成功とリファクタリングを同時にやらない（帽子を2つかぶらない）
- ベタ書き・重複・泥臭い実装でも構わない（次のステップで直す）

**よくある誤り:**
- テストの期待値を実行結果からコピペする（妥当性確認にならない）
- テスト成功と同時にリファクタリングを始める

**コーディングツールとしての実装:**
```python
class Calculator:
    def add(self, a, b):
        return a + b  # 最もシンプルな実装でテストを通す(Green)
```

#### ステップ4: 必要に応じてリファクタリングする

**やること:**
- **ここで初めて**実装の設計を改善する
- 重複を除去し、コードを整理する
- 全テストが引き続き成功することを確認する

**重要な原則:**
- 重複はヒントであって指令ではない（必要な時だけ除去）
- 必要最小限の整理にとどめる（過度なリファクタリングは先送りの兆候）
- 早すぎる抽象化を避ける

**よくある誤り:**
- 次のテストが怖くて過度にリファクタリングする
- まだ2箇所しかないのに抽象化する

**コーディングツールとしての実装:**
```python
# この段階では特にリファクタリング不要
# 次のテストで重複が見えてきたら検討する
```

#### ステップ5: テストリストが空になるまで繰り返す

**やること:**
- テストリストの完了項目にチェックを入れる
- 残りの項目があればステップ2に戻る
- すべて完了したら終了

**終了条件:**
- テストリストが空になった
- コードの動作に対する不安が退屈に変わった

**コーディングツールとしての実装:**
```
# テストリスト
# - [x] 正常系: 有効な入力で期待値を返す
# - [ ] 境界値: 空文字列/null/最大値を処理する ← 次はこれ
# - [ ] 異常系: 不正な入力でエラーを返す
```

---

### コーディングツールとしての実践ガイド

1. **テストリストを常に可視化する**
   - コメントとして書き出し、進捗を追跡可能にする
   - チェックボックス形式で完了状況を明示する

2. **Red-Green-Refactorのリズムを守る**
   - 各サイクルは短く保つ（数分程度）
   - 一度にひとつのステップだけに集中する

3. **設計の2段階を分離する**
   - ステップ2: インターフェイスの設計（どう呼び出すか）
   - ステップ4: 実装の設計（どう実装するか）

4. **ユーザーの要求からテストリストを導出する**
   - 要求を受けたら、まずテストリストに変換する
   - 実装に着手する前にリストの妥当性を確認する

5. **テストは最小限から始める**
   - 最も単純なケースから実装する
   - 複雑なケースは後から追加する
